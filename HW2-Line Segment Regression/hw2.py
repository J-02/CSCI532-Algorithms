# -*- coding: utf-8 -*-
"""HW2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-wPC4eT8WShicOD0WkVzDlnQrtOhjBo-
"""

import random
import numpy as np
import matplotlib.pyplot as plt

def generate_linear_points(n, m, b, x_min, x_max, sd):
    # Generate x values
    x_values = np.linspace(x_min, x_max, n)

    # Compute y values with random errors
    error_terms = np.random.normal(loc=0, scale=sd, size=n)
    y_values = m * x_values + b + error_terms

    # Return pairs of (x, y) values
    return [(x, y) for x, y in zip(x_values, y_values)]

# Generate 100 random points with a linear relationship
points = generate_linear_points(n=100, m=2, b=1, x_min=0, x_max=10, sd=1)

# Extract x and y values from the list of points
x_values = [point[0] for point in points]
y_values = [point[1] for point in points]

# Create a scatter plot of the points
plt.scatter(x_values, y_values)

# Add labels and title to the plot
plt.xlabel('X values')
plt.ylabel('Y values')
plt.title('Randomly Generated Linearly Correlated Points')

# Show the plot
plt.show()

def squared_error(points):
    n = len(points)
    x = [p[0] for p in points]
    y = [p[1] for p in points]
    sx = sum(x)
    sy = sum(y)
    sxx = sum(x_i**2 for x_i in x)
    sxy = sum(x[i]*y[i] for i in range(n))
    a = (n*sxy - sx*sy) / (n*sxx - sx**2+1e-10)  #error here
    b = (sy - a*sx) / n
    error = sum((y[i] - (a*x[i] + b))**2 for i in range(n))
    return error


def segmented_least_squares(points, k):
    n = len(points)
    OPT = np.zeros(shape=[k+1,n])

    for i in range(n):
        OPT[0][i] = squared_error(points[0:i+1]) #error here

    for i in range(1, k):
        for j in range(i, n):
            OPT[i][j] = min(OPT[i - 1][m] + squared_error(points[m + 1:j + 1]) for m in range(i - 1, j))

    segments = []
    j = n - 1
    for i in range(k - 1, -1, -1):
        for m in range(i - 1, j):
            if OPT[i][j] == OPT[i - 1][m] + squared_error(points[m + 1:j + 1]):
                segments.append((m + 1, j))
                j = m
                break

    segments.reverse()
    print(segments)
    return segments



# Set random seed for reproducibility
random.seed(42)

# Number of segments
num_segments = 5

# Number of points per segment
num_points = 20

# Range of x-values for each segment
x_ranges = [(0, 10), (10, 20), (20, 30), (30, 40), (40, 50)]

# Slopes and intercepts for each segment
slopes = [random.randint(-10, 10) for _ in range(num_segments)]
intercepts = [random.randint(-5, 5) for _ in range(num_segments)]

# Generate random points for each segment
points = []
for i in range(num_segments):
    x_start, x_end = x_ranges[i]
    for j in range(num_points):
        x = random.uniform(x_start, x_end)
        y = slopes[i] * x + intercepts[i] + random.uniform(-2, 2)
        points.append((x, y))

# Sort points by x-value
points.sort(key=lambda p: p[0])

# Plot points
plt.scatter([p[0] for p in points], [p[1] for p in points])

segments = segmented_least_squares(points, 5)
for segment in segments:
    x = [points[i][0] for i in range(segment[0], segment[1] + 1)]
    y = [points[i][1] for i in range(segment[0], segment[1] + 1)]
    slope, intercept = np.polyfit(x, y, 1) # added these two lines so should be LS line now
    plt.plot(x, np.polyval([slope, intercept],x))

plt.show()

import matplotlib.pyplot as plt
import numpy as np

segments = 6


# Generates random points that are linearly correlated and in segments/clusters
def generate_points(num_points=20, segments=segments, x_range=100, equal=False):
    x = np.round(np.sort(np.append(np.random.uniform(0, x_range, size=segments - 1), [0, x_range])), 2)

    x.sort()

    # Range of x-values for each segment to generate on (even sized or odd sized)
    if equal == True:
        x_ranges = [((x_range / segments) * i, ((x_range / segments) * (i + 1))) for i in range(segments)]
    else:
        x_ranges = [(x[i], x[i + 1]) for i in range(segments)]

    # Slopes and intercepts for each segment
    slopes = np.random.uniform(-1, 1, size=segments)
    intercepts = np.random.uniform(-10, 10, size=segments)

    # Generate random points for each segment
    points = np.empty([0,2])
    for i in range(segments):
        x_start, x_end = x_ranges[i]
        x = np.random.uniform(x_start, x_end, size=num_points)
        y = slopes[i] * x + intercepts[i] + np.random.uniform(-2, 2, size=num_points)  # Y-coordinates + error
        p = np.column_stack((x,y))
        points = np.row_stack((points,p))

    # Sort points by x-value
    points = points[points[:, 0].argsort()]
    lines = list(zip(slopes, intercepts))
    return points, lines


def segmented_linear_regression(points, k=segments):
    n = len(points)
    OPT = np.zeros(shape=[k, n])

    # Compute the cost matrix for each segment and each data point
    for i in range(n):
        OPT[0][i] = squared_error(points[:i + 1])

    for i in range(1, k):
        for j in range(i, n):
            # Compute the cost for all possible segmentations
            OPT[i][j] = min([OPT[i - 1][m] + squared_error(points[m + 1:j + 1]) for m in range(i - 1, j)])

    # Finding the best segmentation by backtracking through the cost matrix
    segments = []
    xcoords = []
    j = n - 1

    checked = 0
    for i in range(k - 1, -1, -1):
        for m in range(i - 1, j):

            if OPT[i][j] == OPT[i - 1][m] + squared_error(points[m + 1:j + 1]):
                currentRange = points[m + 1:j + 1]  # selects the current range where the segment is located
                x = currentRange[:, 0]  # gets x and y coordinates of data points in the current range
                y = currentRange[:, 1]
                slope, intercept = np.polyfit(x, y, 1)  # linear regression for points in current range
                segments.append((slope, intercept))  # add line to segments
                xcoords.append([currentRange[0][0], currentRange[-1][0]])  # add range of segment
                j = m
                checked += len(currentRange)
                if len(segments) == k - 1:  # final cluster is the points remaining since backtracking
                    currentRange = points[:m]
                    x = currentRange[:, 0]
                    y = currentRange[:, 1]
                    slope, intercept = np.polyfit(x, y, 1)
                    segments.append((slope, intercept))
                    xcoords.append([currentRange[0][0], currentRange[-1][0]])
                break

    segments.reverse()
    xcoords.reverse()
    return segments, xcoords


def squared_error(points):
    # Computing the squared error for given points
    n = len(points)
    x = [points[i][0] for i in range(n)]
    y = [points[i][1] for i in range(n)]
    sum_x = sum(x)
    sum_y = sum(y)
    sum_xx = sum(x[i] ** 2 for i in range(n))
    sum_xy = sum(x[i] * y[i] for i in range(n))
    denominator = n * sum_xx - sum_x ** 2
    if denominator == 0:
        return float('inf')  # vertical slope
    slope = (n * sum_xy - sum_x * sum_y) / denominator
    intercept = (sum_y - slope * sum_x) / n
    error = sum((y[i] - (slope * x[i] + intercept)) ** 2 for i in range(n))
    return error


def plot(points, lines, coords):
    # Plot the input data points
    plt.figure()
    x = [points[i][0] for i in range(len(points))]
    y = [points[i][1] for i in range(len(points))]
    plt.scatter(x, y)

    # Add each segment to the plot w/in its range
    for idx, i in enumerate(segments):
        slope, intercept = i
        x0, xn = coords[idx]
        x = [x0, xn]
        y = [slope * x0 + intercept, slope * xn + intercept]
        plt.plot(x, y, 'r-')

    plt.xlabel('X')
    plt.ylabel('Y')
    plt.title('Segmented Lines')


# Test example
points, lines = generate_points()
segments, x_coords = segmented_linear_regression(points)

# Plotting results
plot(points, segments, x_coords)
plt.savefig('segmented_line_unequalranges.png')
plt.show()
print("regression:")
print(segments)
print("actual")
print(lines)

# with rounding

import matplotlib.pyplot as plt
import numpy as np

segments = 6

# Generates random points that are linearly correlated and in segments/clusters
def generate_points(num_points=20, segments=segments, x_range=100, equal=True):
    x = np.round(np.sort(np.append(np.random.uniform(0, x_range, size=segments - 1), [0, x_range])), 2)

    x.sort()

    # Range of x-values for each segment to generate on (even sized or odd sized)
    if equal == True:
        x_ranges = [(round((x_range / segments) * i,2), (round((x_range / segments) * (i + 1),2))) for i in range(segments)]
    else:
        x_ranges = [(round(x[i],2), round(x[i + 1],2)) for i in range(segments)]

    # Slopes and intercepts for each segment
    slopes = np.round(np.random.uniform(-1, 1, size=segments),2)
    intercepts = np.round(np.random.uniform(-10, 10, size=segments),2)

    # Generate random points for each segment
    points = np.empty([0,2])
    for i in range(segments):
        x_start, x_end = x_ranges[i]
        x = np.random.uniform(x_start, x_end, size=num_points)
        y = slopes[i] * x + intercepts[i] + np.random.uniform(-2, 2, size=num_points)  # Y-coordinates + error
        p = np.column_stack((x,y))
        points = np.row_stack((points,p))

    # Sort points by x-value
    points = np.round(points[points[:, 0].argsort()],2)
    lines = list(zip(slopes, intercepts))
    return points, lines, x_ranges


def segmented_linear_regression(points, k=segments):
    n = len(points)
    OPT = np.zeros(shape=[k, n])

    # Compute the cost matrix for each segment and each data point
    for i in range(n):
        OPT[0][i] = squared_error(points[:i + 1])

    for i in range(1, k):
        for j in range(i, n):
            # Compute the cost for all possible segmentations
            OPT[i][j] = min([OPT[i - 1][m] + squared_error(points[m + 1:j + 1]) for m in range(i - 1, j)])

    # Finding the best segmentation by backtracking through the cost matrix
    segments = []
    xcoords = []
    j = n - 1
    for i in range(k - 1, -1, -1):
        for m in range(i - 1, j):
            if OPT[i][j] == OPT[i - 1][m] + squared_error(points[m + 1:j + 1]):
                currentRange = points[m + 1:j + 1]  # selects the current range where the segment is located
                x = currentRange[:, 0]  # gets x and y coordinates of data points in the current range
                y = currentRange[:, 1]
                slope, intercept = np.polyfit(x, y, 1)  # linear regression for points in current range
                segments.append((round(slope,2), round(intercept,2))) # add line to segments
                xcoords.append([currentRange[0][0], currentRange[-1][0]])  # add range of segment
                j = m
                if len(segments) == k - 1:  # final cluster is the points remaining since backtracking
                    currentRange = points[:m]
                    x = currentRange[:, 0]
                    y = currentRange[:, 1]
                    slope, intercept = np.polyfit(x, y, 1)
                    segments.append((round(slope,2), round(intercept,2)))
                    xcoords.append([currentRange[0][0], currentRange[-1][0]])
                break
    segments.reverse()
    xcoords.reverse()
    return segments, xcoords


def squared_error(points):
    # Computing the squared error for given points
    n = len(points)
    x = [points[i][0] for i in range(n)]
    y = [points[i][1] for i in range(n)]
    sum_x = sum(x)
    sum_y = sum(y)
    sum_xx = sum(x[i] ** 2 for i in range(n))
    sum_xy = sum(x[i] * y[i] for i in range(n))
    denominator = n * sum_xx - sum_x ** 2
    if denominator == 0:
        return float('inf')  # vertical slope
    slope = (n * sum_xy - sum_x * sum_y) / denominator
    intercept = (sum_y - slope * sum_x) / n
    error = sum((y[i] - (slope * x[i] + intercept)) ** 2 for i in range(n))
    return error


def plot(points, lines, coords):
    # Plot the input data points
    plt.figure()
    x = points[:,0]
    y = points[:,1]
    plt.scatter(x, y)

    # Add each segment to the plot w/in its range
    for idx, i in enumerate(segments):
        slope, intercept = i
        x0, xn = coords[idx]
        x = [x0, xn]
        y = [slope * x0 + intercept, slope * xn + intercept]
        plt.plot(x, y, 'r-')

    plt.xlabel('X')
    plt.ylabel('Y')
    plt.title('Segmented Lines')


# Test example
points, lines, x_ranges= generate_points()
segments, x_coords = segmented_linear_regression(points)

# Plotting results
plot(points, segments, x_coords)
plt.savefig('segmented_line_equalranges.png')
plt.show()
print("Regression:")
print(segments)
print("Actual")
print(lines)
print("Regression Ranges")
print(x_coords)
print("Actual Ranges")
print(x_ranges)